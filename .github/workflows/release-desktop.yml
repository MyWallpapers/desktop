name: Desktop Release
run-name: "Release ${{ inputs.bump }} (${{ inputs.mode }})"

on:
  workflow_dispatch:
    inputs:
      bump:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
      mode:
        description: 'Build mode'
        required: true
        type: choice
        options:
          - prod
          - dev

jobs:
  bump-version:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.bump.outputs.version }}
      tag: ${{ steps.bump.outputs.tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Bump version
        id: bump
        run: |
          CURRENT=$(grep -oP '"version":\s*"\K[0-9]+\.[0-9]+\.[0-9]+' src-tauri/tauri.conf.json | head -1)
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"

          case "${{ inputs.bump }}" in
            patch) PATCH=$((PATCH + 1)) ;;
            minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
          esac

          VERSION="$MAJOR.$MINOR.$PATCH"
          SUFFIX="${{ inputs.mode == 'dev' && '-dev' || '' }}"
          TAG="v${VERSION}${SUFFIX}"

          echo "ðŸ“¦ $CURRENT â†’ $VERSION (${{ inputs.bump }})"

          sed -i "s/\"version\": \"$CURRENT\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json
          sed -i "s/^version = \"$CURRENT\"/version = \"$VERSION\"/" src-tauri/Cargo.toml
          sed -i "s/\"version\": \"$CURRENT\"/\"version\": \"$VERSION\"/" package.json

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Commit and tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add src-tauri/tauri.conf.json src-tauri/Cargo.toml package.json
          git commit -m "release: desktop v${{ steps.bump.outputs.version }}"
          git tag "${{ steps.bump.outputs.tag }}"
          git push origin main "${{ steps.bump.outputs.tag }}"

      # Create the draft release ONCE here, before matrix builds start.
      # This prevents tauri-action race conditions where multiple matrix jobs
      # each create a separate release with the same tag.
      - name: Create draft release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.bump.outputs.tag }}"
          PRERELEASE="${{ inputs.mode == 'dev' && '--prerelease' || '' }}"
          BODY="See the assets to download and install.${{ inputs.mode == 'dev' && ' âš ï¸ DEV BUILD â€” unoptimized, devtools enabled.' || '' }}"
          gh release create "$TAG" \
            --draft \
            $PRERELEASE \
            --title "MyWallpaper Desktop ${TAG}" \
            --notes "$BODY" \
            --repo ${{ github.repository }}

  publish-tauri:
    needs: bump-version
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-latest
            args: "--target aarch64-apple-darwin"
          - platform: macos-latest
            args: "--target x86_64-apple-darwin"
          # Linux paused â€” re-enable when WebGPU support is resolved
          # - platform: ubuntu-22.04
          #   args: ""
          - platform: windows-latest
            args: ""

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.bump-version.outputs.tag }}

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: "src-tauri -> target"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        run: npm ci

      - name: Configure dev build
        if: inputs.mode == 'dev'
        shell: bash
        run: |
          echo "CARGO_PROFILE_RELEASE_OPT_LEVEL=0" >> $GITHUB_ENV
          echo "CARGO_PROFILE_RELEASE_LTO=false" >> $GITHUB_ENV
          echo "CARGO_PROFILE_RELEASE_CODEGEN_UNITS=256" >> $GITHUB_ENV
          echo "CARGO_PROFILE_RELEASE_STRIP=none" >> $GITHUB_ENV
          echo "CARGO_PROFILE_RELEASE_INCREMENTAL=true" >> $GITHUB_ENV
          echo "CARGO_INCREMENTAL=1" >> $GITHUB_ENV

      # tauri-action uploads binaries + .sig files to the draft release.
      # It also tries to upload latest.json, which may race across matrix
      # jobs â€” that's fine, we ignore the race and rebuild latest.json
      # authoritatively in publish-release after all builds complete.
      - name: Build and publish
        uses: tauri-apps/tauri-action@v0.5
        continue-on-error: true
        id: tauri
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          tagName: ${{ needs.bump-version.outputs.tag }}
          releaseName: "MyWallpaper Desktop ${{ needs.bump-version.outputs.tag }}"
          releaseBody: "See the assets to download and install.${{ inputs.mode == 'dev' && ' âš ï¸ DEV BUILD â€” unoptimized, devtools enabled.' || '' }}"
          releaseDraft: true
          prerelease: ${{ inputs.mode == 'dev' }}
          args: ${{ matrix.args }} ${{ inputs.mode == 'dev' && '--features devtools' || '' }}

      # Fail the job if the actual build failed (not just latest.json race).
      # Check: if no .sig files were uploaded for this platform, the build truly failed.
      - name: Verify build artifacts
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ needs.bump-version.outputs.tag }}"
          ASSETS=$(gh release view "$TAG" --json assets --jq '[.assets[].name | select(endswith(".sig"))]' --repo ${{ github.repository }})
          COUNT=$(echo "$ASSETS" | jq 'length')
          if [ "$COUNT" -eq 0 ]; then
            echo "::error::No .sig artifacts found in release â€” build failed"
            exit 1
          fi
          echo "âœ“ Found $COUNT signature files in release"

  publish-release:
    needs: [bump-version, publish-tauri]
    if: ${{ !cancelled() && needs.bump-version.result == 'success' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      # Build the canonical latest.json from all .sig assets in the release.
      # This runs once after all builds, so there's no race condition.
      - name: Generate updater manifest
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ needs.bump-version.outputs.tag }}"
          VERSION="${{ needs.bump-version.outputs.version }}"
          REPO="${{ github.repository }}"
          BASE_URL="https://github.com/${REPO}/releases/download/${TAG}"

          # Remove any partial latest.json left by tauri-action
          gh release delete-asset "$TAG" latest.json --yes --repo "$REPO" 2>/dev/null || true

          # Get release metadata
          PUB_DATE=$(gh release view "$TAG" --json createdAt --jq '.createdAt' --repo "$REPO")
          BODY=$(gh release view "$TAG" --json body --jq '.body' --repo "$REPO")

          # Start with empty platforms object
          PLATFORMS='{}'

          # Map .sig files to Tauri updater platform identifiers
          ASSETS=$(gh release view "$TAG" --json assets --jq '.assets[].name' --repo "$REPO")
          TMP_DIR=$(mktemp -d)

          for SIG_FILE in $ASSETS; do
            # Only process .sig files for updater artifacts
            case "$SIG_FILE" in
              *_aarch64.app.tar.gz.sig)   PLATFORM="darwin-aarch64" ;;
              *_x64.app.tar.gz.sig)       PLATFORM="darwin-x86_64" ;;
              *_x64_en-US.msi.zip.sig)    PLATFORM="windows-x86_64" ;;
              *_x64-setup.nsis.zip.sig)   PLATFORM="windows-x86_64-nsis" ;;
              *) continue ;;
            esac

            ARTIFACT="${SIG_FILE%.sig}"
            URL="${BASE_URL}/${ARTIFACT}"

            # Download signature content
            gh release download "$TAG" --pattern "$SIG_FILE" --dir "$TMP_DIR" --repo "$REPO"
            SIG=$(cat "${TMP_DIR}/${SIG_FILE}")

            PLATFORMS=$(echo "$PLATFORMS" | jq \
              --arg p "$PLATFORM" \
              --arg s "$SIG" \
              --arg u "$URL" \
              '. + {($p): {signature: $s, url: $u}}')

            echo "  âœ“ $PLATFORM â†’ $ARTIFACT"
          done

          rm -rf "$TMP_DIR"

          PLATFORM_COUNT=$(echo "$PLATFORMS" | jq 'keys | length')
          if [ "$PLATFORM_COUNT" -eq 0 ]; then
            echo "::error::No updater platforms found in release assets"
            exit 1
          fi

          # Build latest.json
          jq -n \
            --arg version "$VERSION" \
            --arg notes "$BODY" \
            --arg pub_date "$PUB_DATE" \
            --argjson platforms "$PLATFORMS" \
            '{version: $version, notes: $notes, pub_date: $pub_date, platforms: $platforms}' > latest.json

          echo "Generated latest.json with $PLATFORM_COUNT platforms:"
          jq . latest.json

          # Upload to release
          gh release upload "$TAG" latest.json --repo "$REPO"
          echo "âœ“ Updater manifest uploaded"

      - name: Publish release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ needs.bump-version.outputs.tag }}"
          echo "Publishing release ${TAG}..."
          gh release edit "$TAG" --draft=false --repo ${{ github.repository }}
          echo "âœ… Release ${TAG} published!"
